"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initNetworkLogging = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const http = require("http");
const https = require("https");
const url_1 = require("url");
const logs_server_1 = require("./logs-server");
const model_1 = require("./model");
const requests_store_1 = require("./requests.store");
const ui_server_1 = require("./ui-server");
function initNetworkLogging() {
    const agents = [http, https];
    agents.forEach((agent) => {
        const actualRequestHandlerFn = agent.request;
        agent.request = requestProxyFactory(actualRequestHandlerFn, agent === https);
    });
    (0, logs_server_1.initNetworkRequestsServer)();
    (0, ui_server_1.initUiServer)();
}
exports.initNetworkLogging = initNetworkLogging;
function requestProxyFactory(actualRequestHandler, isHttps) {
    return (options, cb) => {
        const requestDetails = new model_1.RequestDetails();
        requestDetails.requestStartTime = new Date().getTime();
        if (typeof options === 'string') {
            requestDetails.url = options;
            requestDetails.method = 'GET';
        }
        else if (options instanceof url_1.URL) {
            requestDetails.url = options.toString();
            requestDetails.method = 'GET';
        }
        else if (options) {
            const connectionType = isHttps ? 'https' : 'http';
            requestDetails.url = `${connectionType}://${options.hostname || options.host}${options.path}`;
            requestDetails.method = options.method;
            requestDetails.requestHeaders = options.headers;
        }
        const proxyCallback = proxyCallbackFactory(cb, requestDetails);
        const request = actualRequestHandler(options, proxyCallback);
        return proxyClientRequestFactory(request, requestDetails);
    };
}
function proxyCallbackFactory(actualCallBack, requestDetails) {
    return (response) => {
        requestDetails.responseHeaders = response.headers;
        if (typeof actualCallBack === 'function') {
            actualCallBack(response);
        }
        handleResponse(response, requestDetails);
    };
}
function handleResponse(response, requestDetails) {
    const responseBuffer = [];
    requestDetails.responseStatusCode = response.statusCode;
    response.on('data', (chunk) => {
        responseBuffer.push(chunk);
    });
    response.on('aborted', () => {
        requestDetails.responseStatusCode = 0;
        requestDetails.requestEndTime = new Date().getTime();
        registerRequest(requestDetails);
    });
    response.on('error', () => {
        requestDetails.responseStatusCode = 0;
        requestDetails.requestEndTime = new Date().getTime();
        registerRequest(requestDetails);
    });
    response.on('end', function handleStreamEnd() {
        try {
            let responseData = responseBuffer.length === 1
                ? responseBuffer[0]
                : Buffer.concat(responseBuffer);
            responseData = responseData.toString();
            requestDetails.responseData = parseResponseData(responseData, requestDetails);
            requestDetails.requestEndTime = new Date().getTime();
            registerRequest(requestDetails);
        }
        catch (err) {
            requestDetails.responseStatusCode = 0;
            requestDetails.requestEndTime = new Date().getTime();
        }
    });
}
function proxyClientRequestFactory(actualRequest, requestDetails) {
    const actualFn = actualRequest.write;
    actualRequest.write = (data) => {
        try {
            requestDetails.requestData = JSON.parse(data.toString());
        }
        catch (err) {
            requestDetails.requestData = data;
        }
        return actualFn.bind(actualRequest)(data);
    };
    actualRequest.on('error', () => {
        requestDetails.responseStatusCode = 0;
        requestDetails.requestEndTime = new Date().getTime();
        registerRequest(requestDetails);
    });
    return actualRequest;
}
function parseResponseData(responseData, requestDetails) {
    var _a;
    const contentType = (_a = requestDetails === null || requestDetails === void 0 ? void 0 : requestDetails.responseHeaders) === null || _a === void 0 ? void 0 : _a['content-type'];
    if (contentType.includes('application/json')) {
        try {
            return JSON.parse(responseData);
        }
        catch (e) {
            return responseData;
        }
    }
    return responseData;
}
function registerRequest(request) {
    (0, requests_store_1.saveRequest)(request);
}
//# sourceMappingURL=network-debugger.js.map