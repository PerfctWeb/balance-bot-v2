"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebsocketClient = exports.parseRawWsMessage = exports.WsConnectionState = void 0;
const events_1 = require("events");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const logger_1 = require("./logger");
const main_client_1 = require("./main-client");
const usdm_client_1 = require("./usdm-client");
const beautifier_1 = __importDefault(require("./util/beautifier"));
const requestUtils_1 = require("./util/requestUtils");
const ws_utils_1 = require("./util/ws-utils");
const WsStore_1 = __importDefault(require("./util/WsStore"));
const wsBaseEndpoints = {
    spot: 'wss://stream.binance.com:9443',
    margin: 'wss://stream.binance.com:9443',
    isolatedMargin: 'wss://stream.binance.com:9443',
    usdm: 'wss://fstream.binance.com',
    usdmTestnet: 'wss://stream.binancefuture.com',
    coinm: 'wss://dstream.binance.com',
    coinmTestnet: 'wss://dstream.binancefuture.com',
    options: 'wss://vstream.binance.com',
    optionsTestnet: 'wss://testnetws.binanceops.com',
};
const loggerCategory = { category: 'binance-ws' };
const READY_STATE_INITIAL = 0;
const READY_STATE_CONNECTING = 1;
const READY_STATE_CONNECTED = 2;
const READY_STATE_CLOSING = 3;
const READY_STATE_RECONNECTING = 4;
var WsConnectionState;
(function (WsConnectionState) {
    WsConnectionState[WsConnectionState["READY_STATE_INITIAL"] = 0] = "READY_STATE_INITIAL";
    WsConnectionState[WsConnectionState["READY_STATE_CONNECTING"] = 1] = "READY_STATE_CONNECTING";
    WsConnectionState[WsConnectionState["READY_STATE_CONNECTED"] = 2] = "READY_STATE_CONNECTED";
    WsConnectionState[WsConnectionState["READY_STATE_CLOSING"] = 3] = "READY_STATE_CLOSING";
    WsConnectionState[WsConnectionState["READY_STATE_RECONNECTING"] = 4] = "READY_STATE_RECONNECTING";
})(WsConnectionState = exports.WsConnectionState || (exports.WsConnectionState = {}));
;
;
;
function throwUnhandledSwitch(x, msg) {
    throw new Error(msg);
}
function parseEventTypeFromMessage(parsedMsg) {
    var _a;
    if (parsedMsg === null || parsedMsg === void 0 ? void 0 : parsedMsg.e) {
        return parsedMsg.e;
    }
    if (Array.isArray(parsedMsg) && parsedMsg.length) {
        return (_a = parsedMsg[0]) === null || _a === void 0 ? void 0 : _a.e;
    }
    return;
}
/**
 * Try to resolve event.data. Example circumstance: {"stream":"!forceOrder@arr","data":{"e":"forceOrder","E":1634653599186,"o":{"s":"IOTXUSDT","S":"SELL","o":"LIMIT","f":"IOC","q":"3661","p":"0.06606","ap":"0.06669","X":"FILLED","l":"962","z":"3661","T":1634653599180}}}
 */
function parseRawWsMessage(event) {
    if (typeof event === 'string') {
        const parsedEvent = JSON.parse(event);
        if (parsedEvent.data) {
            if (typeof parsedEvent.data === 'string') {
                return parseRawWsMessage(parsedEvent.data);
            }
            return parsedEvent.data;
        }
    }
    if (event === null || event === void 0 ? void 0 : event.data) {
        return JSON.parse(event.data);
    }
    return event;
}
exports.parseRawWsMessage = parseRawWsMessage;
class WebsocketClient extends events_1.EventEmitter {
    constructor(options, logger) {
        super();
        this.logger = logger || logger_1.DefaultLogger;
        this.wsStore = new WsStore_1.default(this.logger);
        this.beautifier = new beautifier_1.default();
        this.restClients = {};
        this.options = Object.assign({ pongTimeout: 7500, pingInterval: 10000, reconnectTimeout: 500 }, options);
        this.listenKeyStateStore = {};
        this.wsUrlKeyMap = {};
    }
    getRestClientOptions() {
        return Object.assign(Object.assign(Object.assign({}, this.options), this.options.restOptions), { api_key: this.options.api_key, api_secret: this.options.api_secret });
    }
    connectToWsUrl(url, wsKey, forceNewConnection) {
        const wsRefKey = wsKey || url;
        const oldWs = this.wsStore.getWs(wsRefKey);
        if (oldWs && this.wsStore.isWsOpen(wsRefKey) && !forceNewConnection) {
            this.logger.silly(`connectToWsUrl(): Returning existing open WS connection`, Object.assign(Object.assign({}, loggerCategory), { wsRefKey }));
            return oldWs;
        }
        this.logger.silly(`connectToWsUrl(): Opening WS connection to URL: ${url}`, Object.assign(Object.assign({}, loggerCategory), { wsRefKey }));
        const ws = new isomorphic_ws_1.default(url);
        this.wsUrlKeyMap[url] = wsRefKey;
        if (typeof ws.on === 'function') {
            ws.on('ping', event => this.onWsPing(event, wsRefKey, ws, 'event'));
            ws.on('pong', event => this.onWsPong(event, wsRefKey, 'event'));
            // ws.on('message', event => this.onWsMessage(event, wsRefKey, 'event'));
            // ws.on('close', event => this.onWsClose(event, wsRefKey, ws, url));
            // ws.on('error', event => this.onWsError(event, wsRefKey, ws));
            // ws.on('open', event => this.onWsOpen(event, wsRefKey));
        }
        ws.onopen = event => this.onWsOpen(event, wsRefKey, url);
        ws.onerror = event => this.onWsError(event, wsRefKey, ws);
        ws.onclose = event => this.onWsClose(event, wsRefKey, ws, url);
        ws.onmessage = event => this.onWsMessage(event, wsRefKey, 'function');
        // Not sure these work in the browser, the traditional event listeners are required for ping/pong frames in node
        ws.onping = event => this.onWsPing(event, wsRefKey, ws, 'function');
        ws.onpong = event => this.onWsPong(event, wsRefKey, 'function');
        // Add ws connection with key to store
        this.wsStore.setWs(wsRefKey, ws);
        return ws;
    }
    tryWsSend(wsKey, wsMessage) {
        try {
            this.logger.silly(`Sending upstream ws message: `, Object.assign(Object.assign({}, loggerCategory), { wsMessage, wsKey }));
            if (!wsKey) {
                throw new Error('No wsKey provided');
            }
            const ws = this.getWs(wsKey);
            if (!ws) {
                throw new Error(`No active websocket connection exists for wsKey: ${wsKey}`);
            }
            ws.send(wsMessage);
        }
        catch (e) {
            this.logger.error(`Failed to send WS message`, Object.assign(Object.assign({}, loggerCategory), { wsMessage, wsKey, exception: e }));
        }
    }
    tryWsPing(wsKey) {
        try {
            // this.logger.silly(`Sending upstream ping: `, { ...loggerCategory, wsKey });
            if (!wsKey) {
                throw new Error('No wsKey provided');
            }
            const ws = this.getWs(wsKey);
            if (!ws) {
                throw new Error(`No active websocket connection exists for wsKey: ${wsKey}`);
            }
            // Binance allows unsolicited pongs, so we send both (though we expect a pong in response to our ping if the connection is still alive)
            ws.ping();
            ws.pong();
        }
        catch (e) {
            this.logger.error(`Failed to send WS ping`, Object.assign(Object.assign({}, loggerCategory), { wsKey, exception: e }));
        }
    }
    onWsOpen(ws, wsKey, wsUrl) {
        this.logger.silly(`onWsOpen(): ${wsUrl} : ${wsKey}`);
        if (this.wsStore.isConnectionState(wsKey, READY_STATE_RECONNECTING)) {
            this.logger.info('Websocket reconnected', Object.assign(Object.assign({}, loggerCategory), { wsKey }));
            this.emit('reconnected', { wsKey, ws });
        }
        else {
            this.logger.info('Websocket connected', Object.assign(Object.assign({}, loggerCategory), { wsKey }));
            this.emit('open', { wsKey, ws });
        }
        this.setWsState(wsKey, READY_STATE_CONNECTED);
        const topics = [...this.wsStore.getTopics(wsKey)];
        if (topics.length) {
            this.requestSubscribeTopics(wsKey, topics);
        }
        if (!this.options.disableHeartbeat) {
            const wsState = this.wsStore.get(wsKey, true);
            if (wsState.activePingTimer) {
                clearInterval(wsState.activePingTimer);
            }
            wsState.activePingTimer = setInterval(() => this.sendPing(wsKey), this.options.pingInterval);
        }
    }
    onWsError(error, wsKey, ws) {
        this.logger.error('Websocket error', Object.assign(Object.assign({}, loggerCategory), { wsKey, error }));
        this.parseWsError('Websocket error', error, wsKey);
        if (this.wsStore.isConnectionState(wsKey, READY_STATE_CONNECTED)) {
            this.emit('error', { error, wsKey, ws });
        }
    }
    onWsClose(event, wsKey, ws, wsUrl) {
        const wsConnectionState = this.wsStore.getConnectionState(wsKey);
        this.logger.info('Websocket connection closed', Object.assign(Object.assign({}, loggerCategory), { wsKey, event, wsConnectionState }));
        // User data sockets include the listen key. To prevent accummulation in memory we should clean up old disconnected states
        const { isUserData } = requestUtils_1.getContextFromWsKey(wsKey);
        if (isUserData) {
            this.wsStore.delete(wsKey);
        }
        if (wsConnectionState !== READY_STATE_CLOSING) {
            this.reconnectWithDelay(wsKey, this.options.reconnectTimeout, wsUrl);
            this.emit('reconnecting', { wsKey, event, ws });
        }
        else {
            this.setWsState(wsKey, READY_STATE_INITIAL);
            this.emit('close', { wsKey, event, ws });
        }
    }
    onWsMessage(event, wsKey, source) {
        try {
            this.clearPongTimer(wsKey);
            const msg = parseRawWsMessage(event);
            // Edge case where raw event does not include event type, detect using wsKey and mutate msg.e
            requestUtils_1.appendEventIfMissing(msg, wsKey);
            requestUtils_1.appendEventMarket(msg, wsKey);
            const eventType = parseEventTypeFromMessage(msg);
            if (eventType) {
                this.emit('message', msg);
                if (eventType === 'listenKeyExpired') {
                    const { market } = requestUtils_1.getContextFromWsKey(wsKey);
                    this.logger.info(`${market} listenKey expired - attempting to respawn user data stream: ${wsKey}`);
                    // Just closing the connection (with the last parameter as true) will handle cleanup and respawn
                    this.close(wsKey, true);
                }
                if (this.options.beautify) {
                    // call beautifier here and emit separate msg, if enabled
                    const beautifiedMessage = this.beautifier.beautifyWsMessage(msg, eventType, false);
                    this.emit('formattedMessage', beautifiedMessage);
                    // emit a separate event for user data messages
                    if (!Array.isArray(beautifiedMessage)) {
                        if ([
                            'outboundAccountPosition',
                            'balanceUpdate',
                            'executionReport',
                            'listStatus',
                            'listenKeyExpired',
                            'MARGIN_CALL',
                            'ORDER_TRADE_UPDATE',
                            'ACCOUNT_UPDATE',
                            'ORDER_TRADE_UPDATE',
                            'ACCOUNT_CONFIG_UPDATE',
                        ].includes(eventType)) {
                            this.emit('formattedUserDataMessage', beautifiedMessage);
                        }
                    }
                }
                return;
            }
            if (msg.result !== undefined) {
                this.emit('reply', {
                    type: event.type,
                    data: msg,
                    wsKey,
                });
                return;
            }
            this.logger.warning('Bug? Unhandled ws message event type. Check if appendEventIfMissing needs to parse wsKey.', Object.assign(Object.assign({}, loggerCategory), { parsedMessage: JSON.stringify(msg), rawEvent: event, wsKey, source }));
        }
        catch (e) {
            this.logger.error('Exception parsing ws message: ', Object.assign(Object.assign({}, loggerCategory), { rawEvent: event, wsKey, error: e, source }));
            this.emit('error', { wsKey, error: e, rawEvent: event, source });
        }
    }
    sendPing(wsKey) {
        this.clearPongTimer(wsKey);
        this.logger.silly('Sending ping', Object.assign(Object.assign({}, loggerCategory), { wsKey }));
        this.tryWsPing(wsKey);
        this.wsStore.get(wsKey, true).activePongTimer = setTimeout(() => {
            this.logger.info('Pong timeout - closing socket to reconnect', Object.assign(Object.assign({}, loggerCategory), { wsKey }));
            this.close(wsKey, true);
        }, this.options.pongTimeout);
    }
    onWsPing(event, wsKey, ws, source) {
        this.logger.silly('Received ping, sending pong frame', Object.assign(Object.assign({}, loggerCategory), { wsKey, event, source }));
        ws.pong();
    }
    onWsPong(event, wsKey, source) {
        this.logger.silly('Received pong, clearing pong timer', Object.assign(Object.assign({}, loggerCategory), { wsKey, event, source }));
        this.clearPongTimer(wsKey);
    }
    close(wsKey, willReconnect) {
        var _a;
        this.logger.info('Closing connection', Object.assign(Object.assign({}, loggerCategory), { wsKey }));
        this.setWsState(wsKey, willReconnect ? READY_STATE_RECONNECTING : READY_STATE_CLOSING);
        this.clearTimers(wsKey);
        (_a = this.getWs(wsKey)) === null || _a === void 0 ? void 0 : _a.close();
        ws_utils_1.terminateWs(this.getWs(wsKey));
    }
    closeWs(ws, willReconnect) {
        const wsKey = this.wsUrlKeyMap[ws.url];
        if (!wsKey) {
            throw new Error(`Cannot close websocket as it has no known wsKey attached.`);
        }
        return this.close(wsKey, willReconnect);
    }
    parseWsError(context, error, wsKey) {
        if (!error.message) {
            this.logger.error(`${context} due to unexpected error: `, error);
            return;
        }
        switch (error.message) {
            case 'Unexpected server response: 401':
                this.logger.error(`${context} due to 401 authorization failure.`, Object.assign(Object.assign({}, loggerCategory), { wsKey }));
                break;
            default:
                this.logger.error(`${context} due to unexpected response error: ${error.msg || error.message || error}`, Object.assign(Object.assign({}, loggerCategory), { wsKey, error }));
                break;
        }
    }
    reconnectWithDelay(wsKey, connectionDelayMs, wsUrl) {
        this.clearTimers(wsKey);
        if (this.wsStore.getConnectionState(wsKey) !== READY_STATE_CONNECTING) {
            this.setWsState(wsKey, READY_STATE_RECONNECTING);
        }
        this.logger.info('Reconnecting to websocket with delay...', Object.assign(Object.assign({}, loggerCategory), { wsKey, connectionDelayMs }));
        setTimeout(() => {
            if (wsKey.includes('userData')) {
                const { market, symbol, isTestnet } = requestUtils_1.getContextFromWsKey(wsKey);
                this.logger.info('Reconnecting to user data stream', Object.assign(Object.assign({}, loggerCategory), { wsKey, market, symbol }));
                // We'll set a new one once the new stream respawns, with a diff listenKey in the key
                this.wsStore.delete(wsKey);
                this.respawnUserDataStream(market, symbol, isTestnet);
                return;
            }
            this.logger.info('Reconnecting to public websocket', Object.assign(Object.assign({}, loggerCategory), { wsKey, wsUrl }));
            this.connectToWsUrl(wsUrl, wsKey);
        }, connectionDelayMs);
    }
    clearTimers(wsKey) {
        this.clearPingTimer(wsKey);
        this.clearPongTimer(wsKey);
    }
    // Send a ping at intervals
    clearPingTimer(wsKey) {
        const wsState = this.wsStore.get(wsKey);
        if (wsState === null || wsState === void 0 ? void 0 : wsState.activePingTimer) {
            // @ts-ignore
            clearInterval(wsState.activePingTimer);
            wsState.activePingTimer = undefined;
        }
    }
    // Expect a pong within a time limit
    clearPongTimer(wsKey) {
        const wsState = this.wsStore.get(wsKey);
        if (wsState === null || wsState === void 0 ? void 0 : wsState.activePongTimer) {
            // @ts-ignore
            clearTimeout(wsState.activePongTimer);
            wsState.activePongTimer = undefined;
        }
    }
    getWsBaseUrl(market, wsKey) {
        if (this.options.wsUrl) {
            return this.options.wsUrl;
        }
        return wsBaseEndpoints[market];
    }
    //   // const networkKey = this.options.livenet ? 'livenet' : 'testnet';
    //   // if (this.isLinear() || wsKey.startsWith('linear')){
    //   //   if (wsKey === wsKeyLinearPublic) {
    //   //     return linearEndpoints.public[networkKey];
    //   //   }
    //   //   if (wsKey === wsKeyLinearPrivate) {
    //   //     return linearEndpoints.private[networkKey];
    //   //   }
    //   //   this.logger.error('Unhandled linear wsKey: ', { ...loggerCategory, wsKey });
    //   //   return linearEndpoints[networkKey];
    //   // }
    //   // return inverseEndpoints[networkKey];
    // }
    // private getWsKeyForTopic(baseUrlKey: BinanceBaseUrlKey, topic: string) {
    //   return isSpotBase(baseUrlKey) ? wsKeySpot : getLinearWsKeyForTopic(topic);
    // }
    // public subscribeSpotPublic(wsTopics: string[] | string) {
    //   return this.subscribe('spot', wsTopics);
    // }
    // public unsubscribeSpotPublic(wsTopics: string[] | string) {
    //   return this.unsubscribe('spot', wsTopics);
    // }
    // TODO: force these through single stream, instead of general one
    /**
     * Add topic/topics to WS subscription list
     */
    // public subscribe(baseUrlKey: BinanceBaseUrlKey, wsTopics: string[] | string) {
    //   const topics = Array.isArray(wsTopics) ? wsTopics : [wsTopics];
    //   topics.forEach(topic => this.wsStore.addTopic(
    //     this.getWsKeyForTopic(baseUrlKey, topic),//wsKeySpot
    //     topic
    //   ));
    //   // attempt to send subscription topic per websocket
    //   this.wsStore.getKeys().forEach((wsKey: WsKey) => {
    //     // if connected, send subscription request
    //     if (this.wsStore.isConnectionState(wsKey, READY_STATE_CONNECTED)) {
    //       return this.requestSubscribeTopics(wsKey, topics);
    //     }
    //     // start connection process if it hasn't yet begun. Topics are automatically subscribed to on-connect
    //     if (
    //       !this.wsStore.isConnectionState(wsKey, READY_STATE_CONNECTING) &&
    //       !this.wsStore.isConnectionState(wsKey, READY_STATE_RECONNECTING)
    //     ) {
    //       return this.connectSingleStream(wsKey);
    //     }
    //   });
    // }
    /**
     * Remove topic/topics from WS subscription list
     */
    // public unsubscribe(baseUrlKey: BinanceBaseUrlKey, wsTopics: string[] | string) {
    //   const topics = Array.isArray(wsTopics) ? wsTopics : [wsTopics];
    //   topics.forEach(topic => this.wsStore.deleteTopic(
    //     this.getWsKeyForTopic(baseUrlKey, topic),
    //     topic
    //   ));
    //   this.wsStore.getKeys().forEach((wsKey: WsKey) => {
    //     // unsubscribe request only necessary if active connection exists
    //     if (this.wsStore.isConnectionState(wsKey, READY_STATE_CONNECTED)) {
    //       this.requestUnsubscribeTopics(wsKey, topics);
    //     }
    //   });
    // }
    // /**
    //  * Request connection of all dependent websockets, instead of waiting for automatic connection by library
    //  */
    // public connectAll(): Promise<WebSocket | undefined>[] | undefined {
    //   return [this.connectSingleStream(wsKeySpot)];
    //   // if (this.isInverse()) {
    //   //   return [this.connect(wsKeySpot)];
    //   // }
    //   // if (this.isLinear()) {
    //   //   return [this.connect(wsKeyLinearPublic), this.connect(wsKeyLinearPrivate)];
    //   // }
    // }
    // private async connectSingleStream(streamName: string): Promise<WebSocket | undefined> {
    //   try {
    //     if (this.wsStore.isWsOpen(streamName)) {
    //       this.logger.error('Refused to connect to ws with existing active connection', { ...loggerCategory, wsKey: streamName })
    //       return this.wsStore.getWs(streamName);
    //     }
    //     if (this.wsStore.isConnectionState(streamName, READY_STATE_CONNECTING)) {
    //       this.logger.error('Refused to connect to ws, connection attempt already active', { ...loggerCategory, wsKey: streamName })
    //       return;
    //     }
    //     if (
    //       !this.wsStore.getConnectionState(streamName) ||
    //       this.wsStore.isConnectionState(streamName, READY_STATE_INITIAL)
    //     ) {
    //       this.setWsState(streamName, READY_STATE_CONNECTING);
    //     }
    //     const url = this.getWsUrl(streamName) + '/stream?';
    //     //+ authParams;
    //     const ws = this.connectToWsUrl(url, streamName);
    //     return this.wsStore.setWs(streamName, ws);
    //   } catch (err) {
    //     this.parseWsError('Connection failed', err, streamName);
    //     this.reconnectWithDelay(streamName, this.options.reconnectTimeout!);
    //   }
    // }
    getWs(wsKey) {
        return this.wsStore.getWs(wsKey);
    }
    setWsState(wsKey, state) {
        this.wsStore.setConnectionState(wsKey, state);
    }
    getSpotRestClient() {
        if (!this.restClients.spot) {
            this.restClients.spot = new main_client_1.MainClient(this.getRestClientOptions(), this.options.requestOptions);
        }
        return this.restClients.spot;
    }
    getUSDMRestClient(isTestnet) {
        if (isTestnet) {
            if (!this.restClients.usdmFuturesTestnet) {
                this.restClients.usdmFuturesTestnet = new usdm_client_1.USDMClient(this.getRestClientOptions(), this.options.requestOptions, isTestnet);
            }
            return this.restClients.usdmFuturesTestnet;
        }
        if (!this.restClients.usdmFutures) {
            this.restClients.usdmFutures = new usdm_client_1.USDMClient(this.getRestClientOptions(), this.options.requestOptions);
        }
        return this.restClients.usdmFutures;
    }
    // private getCOINMRestClient(isTestnet?: boolean): COINMClient {
    // }
    /**
     * Send WS message to subscribe to topics. Use subscribe() to call this.
     */
    requestSubscribeTopics(wsKey, topics) {
        const wsMessage = JSON.stringify({
            method: 'SUBSCRIBE',
            params: topics,
            id: new Date().getTime(),
        });
        this.tryWsSend(wsKey, wsMessage);
    }
    /**
     * Send WS message to unsubscribe from topics. Use unsubscribe() to call this.
     */
    requestUnsubscribeTopics(wsKey, topics) {
        const wsMessage = JSON.stringify({
            op: 'UNSUBSCRIBE',
            params: topics,
            id: new Date().getTime(),
        });
        this.tryWsSend(wsKey, wsMessage);
    }
    /**
     * Send WS message to unsubscribe from topics.
     */
    requestListSubscriptions(wsKey, requestId) {
        const wsMessage = JSON.stringify({
            method: 'LIST_SUBSCRIPTIONS',
            id: requestId,
        });
        this.tryWsSend(wsKey, wsMessage);
    }
    /**
     * Send WS message to set property state
     */
    requestSetProperty(wsKey, property, value, requestId) {
        const wsMessage = JSON.stringify({
            method: 'SET_PROPERTY',
            params: [property, value],
            id: requestId,
        });
        this.tryWsSend(wsKey, wsMessage);
    }
    /**
     * Send WS message to get property state
     */
    requestGetProperty(wsKey, property, requestId) {
        const wsMessage = JSON.stringify({
            method: 'GET_PROPERTY',
            params: [property],
            id: requestId,
        });
        this.tryWsSend(wsKey, wsMessage);
    }
    /**
     * --------------------------
     * User data listen key tracking & persistence
     * --------------------------
    **/
    getListenKeyState(listenKey, market) {
        const state = this.listenKeyStateStore[listenKey];
        if (state) {
            return state;
        }
        this.listenKeyStateStore[listenKey] = {
            market,
            lastKeepAlive: 0,
            keepAliveTimer: undefined,
            keepAliveFailures: 0,
        };
        return this.listenKeyStateStore[listenKey];
    }
    setKeepAliveListenKeyTimer(listenKey, market, ws, wsKey, symbol, isTestnet) {
        const listenKeyState = this.getListenKeyState(listenKey, market);
        // this.logger.silly(`setKeepAliveListenKeytimer for ${market} listenKey ${wsKey}`);
        if (listenKeyState.keepAliveTimer) {
            clearInterval(listenKeyState.keepAliveTimer);
        }
        // Set timer to keep WS alive every 50 minutes
        // @ts-ignore
        listenKeyState.keepAliveTimer = setInterval(() => this.checkKeepAliveListenKey(listenKey, market, ws, wsKey, symbol, isTestnet), 1000 * 60 * 50);
    }
    sendKeepAliveForMarket(listenKey, market, ws, wsKey, symbol, isTestnet) {
        switch (market) {
            case 'spot':
                return this.getSpotRestClient().keepAliveSpotUserDataListenKey(listenKey);
            case 'margin':
                return this.getSpotRestClient().keepAliveMarginUserDataListenKey(listenKey);
            case 'isolatedMargin':
                return this.getSpotRestClient().keepAliveIsolatedMarginUserDataListenKey({ listenKey, symbol: symbol });
            case 'coinm':
            case 'coinmTestnet':
            case 'options':
            case 'optionsTestnet':
            case 'usdm':
                return this.getUSDMRestClient().keepAliveFuturesUserDataListenKey();
            case 'usdmTestnet':
                return this.getUSDMRestClient(isTestnet).keepAliveFuturesUserDataListenKey();
            default:
                throwUnhandledSwitch(market, `Failed to send keep alive for user data stream in unhandled market ${market}`);
        }
    }
    checkKeepAliveListenKey(listenKey, market, ws, wsKey, symbol, isTestnet) {
        return __awaiter(this, void 0, void 0, function* () {
            const listenKeyState = this.getListenKeyState(listenKey, market);
            try {
                yield this.sendKeepAliveForMarket(listenKey, market, ws, wsKey, symbol, isTestnet);
                listenKeyState.lastKeepAlive = Date.now();
                listenKeyState.keepAliveFailures = 0;
                this.logger.info(`Completed keep alive cycle for listenKey(${listenKey}) in market(${market})`, Object.assign(Object.assign({}, loggerCategory), { listenKey }));
            }
            catch (e) {
                listenKeyState.keepAliveFailures++;
                // If max failurees reached, tear down and respawn if allowed
                if (listenKeyState.keepAliveFailures >= 3) {
                    this.logger.error('FATAL: Failed to keep WS alive for listen key after 3 attempts', Object.assign(Object.assign({}, loggerCategory), { listenKey, error: e }));
                    this.teardownUserDataListenKey(listenKey, market, ws);
                    this.respawnUserDataStream(market, symbol);
                    return;
                }
                this.logger.warning('User key refresh failed due to error, trying again with short delay', Object.assign(Object.assign({}, loggerCategory), { listenKey, error: e, keepAliveAttempts: listenKeyState.keepAliveFailures }));
                setTimeout(() => this.checkKeepAliveListenKey(listenKey, market, ws, wsKey, symbol), 1000 * 15);
            }
        });
    }
    teardownUserDataListenKey(listenKey, market, ws) {
        const listenKeyState = this.getListenKeyState(listenKey, market);
        clearInterval(listenKeyState.keepAliveFailures);
        ws_utils_1.terminateWs(ws);
        delete this.listenKeyStateStore[listenKey];
    }
    respawnUserDataStream(market, symbol, isTestnet, respawnAttempt) {
        return __awaiter(this, void 0, void 0, function* () {
            const forceNewConnection = true;
            const isReconnecting = true;
            let ws;
            try {
                switch (market) {
                    case 'spot':
                        ws = yield this.subscribeSpotUserDataStream(forceNewConnection, isReconnecting);
                        break;
                    case 'margin':
                        ws = yield this.subscribeMarginUserDataStream(forceNewConnection, isReconnecting);
                        break;
                    case 'isolatedMargin':
                        ws = yield this.subscribeIsolatedMarginUserDataStream(symbol, forceNewConnection, isReconnecting);
                        break;
                    case 'usdm':
                        ws = yield this.subscribeUsdFuturesUserDataStream(isTestnet, forceNewConnection, isReconnecting);
                        break;
                    case 'usdmTestnet':
                        ws = yield this.subscribeUsdFuturesUserDataStream(true, forceNewConnection, isReconnecting);
                        break;
                    case 'coinm':
                    case 'coinmTestnet':
                    case 'options':
                    case 'optionsTestnet':
                        throw new Error('TODO: respawn other user data streams once subscribe methods have been aded');
                    default:
                        throwUnhandledSwitch(market, `Failed to respawn user data stream - unhandled market: ${market}`);
                }
            }
            catch (e) {
                this.logger.error('Exception trying to spawn user data stream', Object.assign(Object.assign({}, loggerCategory), { market, symbol, isTestnet, error: e }));
                this.emit('error', { wsKey: market + '_' + 'userData', error: e });
            }
            if (!ws) {
                const delayInSeconds = 2;
                this.logger.error('User key respawn failed, trying again with short delay', Object.assign(Object.assign({}, loggerCategory), { market, symbol, isTestnet, respawnAttempt, delayInSeconds }));
                setTimeout(() => this.respawnUserDataStream(market, symbol, isTestnet, respawnAttempt ? respawnAttempt + 1 : 1), 1000 * delayInSeconds);
            }
        });
    }
    /**
     * --------------------------
     * Universal market websocket streams (may apply to one or more API markets)
     * --------------------------
    **/
    /**
     * Subscribe to aggregate trades for a symbol in a market category
     */
    subscribeAggregateTrades(symbol, market, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'aggTrade';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to coin index for a symbol in COINM Futures markets
     */
    subscribeCoinIndexPrice(symbol, updateSpeedMs = 3000, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'indexPrice';
        const speedSuffix = updateSpeedMs === 1000 ? '@1s' : '';
        const market = 'coinm';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}${speedSuffix}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to mark price for a symbol in a market category
     */
    subscribeMarkPrice(symbol, market, updateSpeedMs = 3000, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'markPrice';
        const speedSuffix = updateSpeedMs === 1000 ? '@1s' : '';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}${speedSuffix}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to mark price for all symbols in a market category
     */
    subscribeAllMarketMarkPrice(market, updateSpeedMs = 3000, forceNewConnection) {
        const streamName = '!markPrice@arr';
        const speedSuffix = updateSpeedMs === 1000 ? '@1s' : '';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${streamName}${speedSuffix}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to klines(candles) for a symbol in a market category
     */
    subscribeKlines(symbol, interval, market, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'kline';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol, interval);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}_${interval}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to continuous contract klines(candles) for a symbol futures
     */
    subscribeContinuousContractKlines(symbol, contractType, interval, market, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'continuousKline';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol, interval);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}_${contractType}@${streamName}_${interval}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to index klines(candles) for a symbol in a coinm futures
     */
    subscribeIndexKlines(symbol, interval, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'indexPriceKline';
        const market = 'coinm';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol, interval);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}_${interval}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to index klines(candles) for a symbol in a coinm futures
     */
    subscribeMarkPriceKlines(symbol, interval, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'markPrice_kline';
        const market = 'coinm';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol, interval);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}_${interval}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to mini 24hr ticker for a symbol in market category.
     */
    subscribeSymbolMini24hrTicker(symbol, market, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'miniTicker';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to mini 24hr mini ticker in market category.
     */
    subscribeAllMini24hrTickers(market, forceNewConnection) {
        const streamName = 'miniTicker';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/!${streamName}@arr`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to 24hr ticker for a symbol in any market.
     */
    subscribeSymbol24hrTicker(symbol, market, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'ticker';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to 24hr ticker in any market.
     */
    subscribeAll24hrTickers(market, forceNewConnection) {
        const streamName = 'ticker';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/!${streamName}@arr`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to best bid/ask for symbol in spot markets.
     */
    subscribeSymbolBookTicker(symbol, market, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'bookTicker';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to best bid/ask for all symbols in spot markets.
     */
    subscribeAllBookTickers(market, forceNewConnection) {
        const streamName = 'bookTicker';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/!${streamName}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to best bid/ask for symbol in spot markets.
     */
    subscribeSymbolLiquidationOrders(symbol, market, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'forceOrder';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to best bid/ask for all symbols in spot markets.
     */
    subscribeAllLiquidationOrders(market, forceNewConnection) {
        const streamName = 'forceOrder@arr';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/!${streamName}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to partial book depths. Note, spot only supports 1000ms or 100ms for updateMs, while futures only support 100, 250 or 500ms.
     */
    subscribePartialBookDepths(symbol, levels, updateMs, market, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'depth';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol);
        const updateMsSuffx = updateMs === 100 ? `@${updateMs}ms` : '';
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}${levels}${updateMsSuffx}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to spot orderbook depth updates to locally manage an order book.
     */
    subscribeDiffBookDepth(symbol, updateMs = 1000, market, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const streamName = 'depth';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, 'diffBookDepth', lowerCaseSymbol, String(updateMs));
        const updateMsSuffx = updateMs === 100 ? `@${updateMs}ms` : '';
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}${updateMsSuffx}`, wsKey, forceNewConnection);
    }
    /**
     * --------------------------
     * SPOT market websocket streams
     * --------------------------
    **/
    /**
     * Subscribe to aggregate trades for a symbol in spot markets.
     */
    subscribeSpotAggregateTrades(symbol, forceNewConnection) {
        return this.subscribeAggregateTrades(symbol, 'spot', forceNewConnection);
    }
    /**
     * Subscribe to candles for a symbol in spot markets.
     */
    subscribeSpotTrades(symbol, forceNewConnection) {
        const lowerCaseSymbol = symbol.toLowerCase();
        const market = 'spot';
        const streamName = 'trade';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, streamName, lowerCaseSymbol);
        return this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${lowerCaseSymbol}@${streamName}`, wsKey, forceNewConnection);
    }
    /**
     * Subscribe to candles for a symbol in spot markets.
     */
    subscribeSpotKline(symbol, interval, forceNewConnection) {
        return this.subscribeKlines(symbol, interval, 'spot', forceNewConnection);
    }
    /**
     * Subscribe to mini 24hr ticker for a symbol in spot markets.
     */
    subscribeSpotSymbolMini24hrTicker(symbol, forceNewConnection) {
        return this.subscribeSymbolMini24hrTicker(symbol, 'spot', forceNewConnection);
    }
    /**
     * Subscribe to mini 24hr mini ticker in spot markets.
     */
    subscribeSpotAllMini24hrTickers(forceNewConnection) {
        return this.subscribeAllMini24hrTickers('spot', forceNewConnection);
    }
    /**
     * Subscribe to 24hr ticker for a symbol in spot markets.
     */
    subscribeSpotSymbol24hrTicker(symbol, forceNewConnection) {
        return this.subscribeSymbol24hrTicker(symbol, 'spot', forceNewConnection);
    }
    /**
     * Subscribe to 24hr ticker in spot markets.
     */
    subscribeSpotAll24hrTickers(forceNewConnection) {
        return this.subscribeAll24hrTickers('spot', forceNewConnection);
    }
    /**
     * Subscribe to best bid/ask for symbol in spot markets.
     */
    subscribeSpotSymbolBookTicker(symbol, forceNewConnection) {
        return this.subscribeSymbolBookTicker(symbol, 'spot', forceNewConnection);
    }
    /**
     * Subscribe to best bid/ask for all symbols in spot markets.
     */
    subscribeSpotAllBookTickers(forceNewConnection) {
        return this.subscribeAllBookTickers('spot', forceNewConnection);
    }
    /**
     * Subscribe to top bid/ask levels for symbol in spot markets.
     */
    subscribeSpotPartialBookDepth(symbol, levels, updateMs = 1000, forceNewConnection) {
        return this.subscribePartialBookDepths(symbol, levels, updateMs, 'spot', forceNewConnection);
    }
    /**
     * Subscribe to spot orderbook depth updates to locally manage an order book.
     */
    subscribeSpotDiffBookDepth(symbol, updateMs = 1000, forceNewConnection) {
        return this.subscribeDiffBookDepth(symbol, updateMs, 'spot', forceNewConnection);
    }
    /**
     * Subscribe to a spot user data stream. Use REST client to generate and persist listen key.
     * Supports spot, margin & isolated margin listen keys.
     */
    subscribeSpotUserDataStreamWithListenKey(listenKey, forceNewConnection, isReconnecting) {
        const market = 'spot';
        const wsKey = requestUtils_1.getWsKeyWithContext(market, 'userData', undefined, listenKey);
        if (!forceNewConnection && this.wsStore.isWsConnecting(wsKey)) {
            this.logger.silly('Existing spot user data connection in progress for listen key. Avoiding duplicate');
            return this.getWs(wsKey);
        }
        this.setWsState(wsKey, isReconnecting ? READY_STATE_RECONNECTING : READY_STATE_CONNECTING);
        const ws = this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${listenKey}`, wsKey, forceNewConnection);
        // Start & store timer to keep alive listen key (and handle expiration)
        this.setKeepAliveListenKeyTimer(listenKey, market, ws, wsKey);
        return ws;
    }
    /**
     * Subscribe to spot user data stream - listen key is automatically generated. Calling multiple times only opens one connection.
     */
    subscribeSpotUserDataStream(forceNewConnection, isReconnecting) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { listenKey } = yield this.getSpotRestClient().getSpotUserDataListenKey();
                return this.subscribeSpotUserDataStreamWithListenKey(listenKey, forceNewConnection, isReconnecting);
            }
            catch (e) {
                this.logger.error(`Failed to connect to spot user data`, Object.assign(Object.assign({}, loggerCategory), { error: e }));
                this.emit('error', { wsKey: 'spot' + '_' + 'userData', error: e });
            }
        });
    }
    /**
     * Subscribe to margin user data stream - listen key is automatically generated.
     */
    subscribeMarginUserDataStream(forceNewConnection, isReconnecting) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { listenKey } = yield this.getSpotRestClient().getMarginUserDataListenKey();
                const market = 'margin';
                const wsKey = requestUtils_1.getWsKeyWithContext(market, 'userData', undefined, listenKey);
                if (!forceNewConnection && this.wsStore.isWsConnecting(wsKey)) {
                    this.logger.silly('Existing margin user data connection in progress for listen key. Avoiding duplicate');
                    return this.getWs(wsKey);
                }
                this.setWsState(wsKey, isReconnecting ? READY_STATE_RECONNECTING : READY_STATE_CONNECTING);
                const ws = this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${listenKey}`, wsKey, forceNewConnection);
                // Start & store timer to keep alive listen key (and handle expiration)
                this.setKeepAliveListenKeyTimer(listenKey, market, ws, wsKey);
                return ws;
            }
            catch (e) {
                this.logger.error(`Failed to connect to margin user data`, Object.assign(Object.assign({}, loggerCategory), { error: e }));
                this.emit('error', { wsKey: 'margin' + '_' + 'userData', error: e });
            }
        });
    }
    /**
     * Subscribe to isolated margin user data stream - listen key is automatically generated.
     */
    subscribeIsolatedMarginUserDataStream(symbol, forceNewConnection, isReconnecting) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const lowerCaseSymbol = symbol.toLowerCase();
                const { listenKey } = yield this.getSpotRestClient().getIsolatedMarginUserDataListenKey({ symbol: lowerCaseSymbol });
                const market = 'isolatedMargin';
                const wsKey = requestUtils_1.getWsKeyWithContext(market, 'userData', lowerCaseSymbol, listenKey);
                if (!forceNewConnection && this.wsStore.isWsConnecting(wsKey)) {
                    this.logger.silly('Existing isolated margin user data connection in progress for listen key. Avoiding duplicate');
                    return this.getWs(wsKey);
                }
                this.setWsState(wsKey, isReconnecting ? READY_STATE_RECONNECTING : READY_STATE_CONNECTING);
                const ws = this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${listenKey}`, wsKey, forceNewConnection);
                // Start & store timer to keep alive listen key (and handle expiration)
                this.setKeepAliveListenKeyTimer(listenKey, market, ws, wsKey, symbol);
                return ws;
            }
            catch (e) {
                this.logger.error(`Failed to connect to isolated margin user data`, Object.assign(Object.assign({}, loggerCategory), { error: e, symbol }));
                this.emit('error', { wsKey: 'isolatedMargin' + '_' + 'userData', error: e });
            }
        });
    }
    /**
     * --------------------------
     * End of SPOT market websocket streams
     * --------------------------
    **/
    /**
     * Subscribe to USD-M Futures user data stream - listen key is automatically generated.
     */
    subscribeUsdFuturesUserDataStream(isTestnet, forceNewConnection, isReconnecting) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { listenKey } = yield this.getUSDMRestClient(isTestnet).getFuturesUserDataListenKey();
                const market = isTestnet ? 'usdmTestnet' : 'usdm';
                const streamName = 'userData';
                const wsKey = [market, streamName, listenKey].join('_');
                if (!forceNewConnection && this.wsStore.isWsConnecting(wsKey)) {
                    this.logger.silly('Existing usd futures user data connection in progress for listen key. Avoiding duplicate');
                    return this.getWs(wsKey);
                }
                // Necessary so client knows this is a reconnect
                this.setWsState(wsKey, isReconnecting ? READY_STATE_RECONNECTING : READY_STATE_CONNECTING);
                const ws = this.connectToWsUrl(this.getWsBaseUrl(market, wsKey) + `/ws/${listenKey}`, wsKey, forceNewConnection);
                // Start & store timer to keep alive listen key (and handle expiration)
                this.setKeepAliveListenKeyTimer(listenKey, market, ws, wsKey, undefined, isTestnet);
                return ws;
            }
            catch (e) {
                this.logger.error(`Failed to connect to USD Futures user data`, Object.assign(Object.assign({}, loggerCategory), { error: e }));
                this.emit('error', { wsKey: 'usdm' + '_' + 'userData', error: e });
            }
        });
    }
}
exports.WebsocketClient = WebsocketClient;
;
//# sourceMappingURL=websocket-client.js.map